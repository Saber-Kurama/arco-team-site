"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const glob_1 = __importDefault(require("glob"));
const webpack_sources_1 = require("webpack-sources");
const parseComment_1 = __importDefault(require("./parseComment"));
const parseRawComment_1 = __importDefault(require("./parseRawComment"));
const parseDependencies_1 = __importDefault(require("./parseDependencies"));
const parseModuleExport_1 = __importDefault(require("./parseModuleExport"));
const tryGetUMDInfo_1 = __importDefault(require("../utils/tryGetUMDInfo"));
const constant_1 = require("../constant");
const encodeInfo_1 = __importDefault(require("../utils/encodeInfo"));
const getTitleOfMarkdown_1 = __importDefault(require("../utils/getTitleOfMarkdown"));
class ArcoSiteModuleInfoPlugin {
    constructor(options) {
        options = options || {};
        const { globs } = options;
        this.options = options;
        this.paths = {
            doc: globs.doc ? glob_1.default.sync(globs.doc).map((item) => path_1.default.resolve(item)) : [],
            demo: globs.demo ? glob_1.default.sync(globs.demo).map((item) => path_1.default.resolve(item)) : [],
        };
    }
    parseModuleExport({ context, filePathList, statsModules, needRawCode = false }) {
        const fileDependencyMap = {};
        const { modules } = (0, parseDependencies_1.default)(statsModules);
        // Filter unnecessary dependency information, and convert the path to an absolute path
        Object.entries(modules).forEach(([modulePath, dependencies]) => {
            modulePath = path_1.default.resolve(context, modulePath);
            if (filePathList.indexOf(modulePath) > -1) {
                fileDependencyMap[modulePath] = dependencies
                    .map((filePath) => path_1.default.resolve(context, filePath))
                    .filter((filePath) => filePath.indexOf('node_modules') === -1);
            }
        });
        return (0, parseModuleExport_1.default)({
            context,
            statsModules,
            needRawCode,
            validPaths: filePathList,
            fileDependencyMap,
        });
    }
    getModuleInfoMap({ chunkInfoList, moduleExportMap, }) {
        // Parse raw comment
        const rawDemoCommentMap = {};
        this.paths.demo.forEach((demoPath) => {
            rawDemoCommentMap[demoPath] = (0, parseRawComment_1.default)(fs_1.default.readFileSync(demoPath, 'utf-8'));
        });
        const moduleInfoMap = {};
        for (const { name: chunkName, entry } of chunkInfoList) {
            if (!moduleExportMap[entry]) {
                continue;
            }
            // Parse comment of target language
            const demoCommentMap = {};
            Object.entries(rawDemoCommentMap).forEach(([demoPath, commentList]) => {
                demoCommentMap[demoPath] = commentList.map((comment) => {
                    // memberof and memberOf both works fine
                    if (comment.memberof) {
                        comment.memberOf = comment.memberof;
                    }
                    return (0, parseComment_1.default)({
                        comment,
                        targetLanguage: chunkName,
                    });
                });
            });
            // Inject comment for module info
            moduleInfoMap[chunkName] = moduleExportMap[entry]
                .map(({ name, moduleFilePath }) => {
                if (this.paths.doc.indexOf(moduleFilePath) > -1) {
                    return {
                        name,
                        info: {
                            name: (0, getTitleOfMarkdown_1.default)(moduleFilePath),
                        },
                        isDoc: true,
                    };
                }
                if (this.paths.demo.indexOf(moduleFilePath) > -1) {
                    const demoList = moduleExportMap[moduleFilePath];
                    if (demoList) {
                        const commentList = demoCommentMap[moduleFilePath];
                        const componentInfo = commentList ? commentList[0] : {};
                        const demoInfoList = commentList ? commentList.slice(-demoList.length) : [];
                        // Try to get umd info of component
                        componentInfo.umd = (0, tryGetUMDInfo_1.default)(moduleFilePath);
                        return {
                            name,
                            info: componentInfo,
                            children: demoList.map(({ name, rawCode }, index) => {
                                return {
                                    name,
                                    rawCode,
                                    info: demoInfoList[index] || {},
                                };
                            }),
                        };
                    }
                }
            })
                .filter((info) => info);
        }
        return moduleInfoMap;
    }
    apply(compiler) {
        const { globs } = this.options;
        const paths = {
            doc: globs.doc ? glob_1.default.sync(globs.doc).map((item) => path_1.default.resolve(item)) : [],
            demo: globs.demo ? glob_1.default.sync(globs.demo).map((item) => path_1.default.resolve(item)) : [],
        };
        let moduleExportMap = {};
        let hasInjectedModuleInfo = false;
        const chunkInfoList = [];
        const getNewSource = (source, moduleInfo) => {
            return source.replace(new RegExp(constant_1.PLACEHOLDER_ARCO_SITE_MODULE_INFO, 'g'), (0, encodeInfo_1.default)(moduleInfo));
        };
        compiler.hooks.compilation.tap('ArcoSiteModuleInfoPlugin', (compilation) => {
            compilation.hooks.optimizeModules.tap('ArcoSiteModuleInfoPlugin', () => {
                const chunkList = [...compilation.chunks];
                chunkList.forEach((chunk) => {
                    if (compilation.chunkGraph !== undefined) {
                        for (const module of compilation.chunkGraph.getChunkEntryModulesIterable(chunk)) {
                            if (module.resource.indexOf('/node_modules/') === -1) {
                                chunkInfoList.push({
                                    name: chunk.name,
                                    entry: module.resource,
                                });
                            }
                        }
                    }
                    else {
                        const { name, entryModule } = chunk;
                        chunkInfoList.push({
                            name,
                            entry: entryModule.resource,
                        });
                    }
                });
                // Parse the export module info of entry file and demo file
                moduleExportMap = this.parseModuleExport({
                    context: compiler.context,
                    statsModules: compilation.getStats().toJson({
                        source: true,
                        providedExports: true,
                    }).modules,
                    filePathList: paths.demo.concat(chunkInfoList.map(({ entry }) => entry)),
                    needRawCode: true,
                });
            });
            // [Webpack5] Needs to process resource content in processAssets
            if (compilation.hooks.processAssets) {
                compilation.hooks.processAssets.tap('ArcoSiteModuleInfoPlugin', (assets) => {
                    const moduleInfoMap = this.getModuleInfoMap({
                        moduleExportMap,
                        chunkInfoList,
                    });
                    for (const filename in assets) {
                        if (assets.hasOwnProperty(filename) && filename.endsWith('.js')) {
                            const chunkName = Object.keys(compiler.options.entry).find((chunkName) => compiler.options.output.filename.replace('.[name].', `.${chunkName}.`) ===
                                filename);
                            if (moduleInfoMap[chunkName]) {
                                compilation.updateAsset(filename, new webpack_sources_1.RawSource(getNewSource(assets[filename].source(), moduleInfoMap[chunkName])));
                            }
                        }
                    }
                    hasInjectedModuleInfo = true;
                });
            }
        });
        // [Webpack4] Processes the final result during emit
        compiler.hooks.emit.tapPromise('ArcoSiteModuleInfoPlugin', (compilation) => __awaiter(this, void 0, void 0, function* () {
            if (hasInjectedModuleInfo) {
                return;
            }
            // Supplement the asset file name information in chunkInfo
            compilation.chunks.forEach(({ name, files }) => {
                const info = chunkInfoList.find((i) => i.name === name);
                if (info) {
                    info.files = files;
                }
            });
            const moduleInfoMap = this.getModuleInfoMap({
                chunkInfoList,
                moduleExportMap,
            });
            chunkInfoList.forEach(({ name: chunkName, files }) => {
                // Inject the extracted module information
                files &&
                    files.forEach((file) => {
                        if (moduleInfoMap[chunkName]) {
                            const asset = compilation.assets[file];
                            const source = asset.source();
                            asset.source = () => getNewSource(source, moduleInfoMap[chunkName]);
                        }
                    });
            });
        }));
    }
}
exports.default = ArcoSiteModuleInfoPlugin;
// Don't delete this, make sure direct require is available
module.exports = ArcoSiteModuleInfoPlugin;
