"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const glob_1 = __importDefault(require("glob"));
const parse_es_import_1 = __importDefault(require("parse-es-import"));
/**
 * Parse exported modules of file
 */
function parseModuleExport({ statsModules, context, validPaths, fileDependencyMap, needRawCode, }) {
    const result = {};
    if (!Object.keys(fileDependencyMap).length) {
        return result;
    }
    for (const { name, source } of statsModules) {
        const pathCurrent = path_1.default.resolve(context, name);
        const dirPathCurrent = path_1.default.dirname(pathCurrent);
        if (validPaths.indexOf(pathCurrent) === -1) {
            continue;
        }
        const moduleInfoList = [];
        const { imports, exports } = (0, parse_es_import_1.default)(source);
        for (const { type, moduleName, value } of exports) {
            switch (type) {
                case 'ExportSpecifier': {
                    let pathImport = path_1.default.resolve(dirPathCurrent, value);
                    if (fs_1.default.existsSync(pathImport) && fs_1.default.lstatSync(pathImport).isDirectory()) {
                        pathImport = `${pathImport}/index`;
                    }
                    pathImport = glob_1.default.sync(`${pathImport}?(.jsx|.js|.ts|.tsx)`).pop();
                    if (pathImport) {
                        let rawCode = '';
                        if (needRawCode) {
                            try {
                                rawCode = fs_1.default.readFileSync(pathImport, 'utf8');
                            }
                            catch (e) {
                                rawCode = 'Failed to get demo code.';
                            }
                        }
                        moduleInfoList.push({
                            name: moduleName,
                            rawCode,
                            moduleFilePath: pathImport,
                        });
                    }
                    break;
                }
                case 'FunctionDeclaration':
                case 'VariableDeclaration': {
                    // Coupled with the content of the file, the content that needs to be parsed is as follows
                    // import * as _DOC from 'xxx.md';
                    // export const DOC = _DOC;
                    let moduleFilePath = '';
                    let rawCode = needRawCode ? value : '';
                    for (const { starImport, defaultImport, moduleName: importModuleName } of imports) {
                        if (moduleName === starImport.replace(/^_/, '') ||
                            moduleName === defaultImport.replace(/^_/, '')) {
                            const [pathImport] = glob_1.default.sync(path_1.default.resolve(dirPathCurrent, `${importModuleName}?(.jsx|.js|.ts|.tsx)`));
                            if (pathImport) {
                                moduleFilePath = pathImport;
                                rawCode = needRawCode ? fs_1.default.readFileSync(pathImport, 'utf8') : '';
                            }
                            break;
                        }
                    }
                    moduleInfoList.push({
                        name: moduleName,
                        rawCode,
                        moduleFilePath,
                    });
                    break;
                }
                default:
                    break;
            }
        }
        result[pathCurrent] = moduleInfoList;
    }
    return result;
}
exports.default = parseModuleExport;
